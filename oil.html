<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ»‘æ²¹åŒ–é©—å ±å‘Š</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <link rel="stylesheet" href="css/style-oil.css">

</head>
<body>

<div id="navbar-placeholder"></div>

<div class="container">
    <h2>
        åŒ–é©—çµæœç¸½è¦½
        <button class="btn-theme" onclick="toggleTheme()" style="float:right">ğŸŒ“ åˆ‡æ›æ¨¡å¼</button>
    </h2>
    
    <div class="table-controls">
        <label>ğŸ“… ç¯©é¸æ—¥æœŸï¼š</label>
        <select id="tableYear" onchange="renderOverviewTables()">
            <option value="latest">æœ€æ–°æ•¸æ“š</option>
        </select>
        <select id="tableMonth" onchange="renderOverviewTables()">
            <option value="all">å…¨éƒ¨æœˆä»½</option>
            <option value="1">1æœˆ</option><option value="2">2æœˆ</option><option value="3">3æœˆ</option>
            <option value="4">4æœˆ</option><option value="5">5æœˆ</option><option value="6">6æœˆ</option>
            <option value="7">7æœˆ</option><option value="8">8æœˆ</option><option value="9">9æœˆ</option>
            <option value="10">10æœˆ</option><option value="11">11æœˆ</option><option value="12">12æœˆ</option>
        </select>
    </div>

    <div id="loading">è³‡æ–™è¼‰å…¥ä¸­...</div>
    
    <h3 class="section-title">ç™¼é›»æ©Ÿçµ„ (#1 ~ #12)</h3>
    <div class="table-container">
        <table class="overview-table" id="dgTable"></table>
    </div>

    <h3 class="section-title">ç·Šæ€¥ç™¼é›»æ©Ÿ (EG)</h3>
    <div class="table-container">
        <table class="overview-table" id="egTable"></table>
    </div>

    <div class="chart-section">
        <h2 style="border-left:5px solid #607d8b; padding-left:10px;">æ­·å²è¶¨å‹¢åˆ†æ (å¤šæ©Ÿçµ„æ¯”è¼ƒ)</h2>
        <div class="chart-controls">
            <div class="control-group" style="flex:2;">
                <label>æ©Ÿçµ„é¸æ“‡ (å¯è¤‡é¸)ï¼š</label>
                <div id="machineCheckboxes" class="checkbox-container"></div>
            </div>
            <div class="control-group">
                <label>æ¸¬é …ï¼š</label>
                <select id="chartParam" onchange="updateChart()"></select>
            </div>
            <div class="control-group">
                <label>å¹´åº¦ï¼š</label>
                <select id="chartYear" onchange="updateChart()">
                    <option value="all">å…¨éƒ¨å¹´ä»½</option>
                </select>
            </div>
        </div>
        <div style="height: 450px;">
            <canvas id="historyChart"></canvas>
        </div>
    </div>
</div>

<div id="detailModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="modalTitle" style="margin:0;">æ©Ÿçµ„è©³æƒ…</h3>
            <span class="close-btn" onclick="closeModal()">&times;</span>
        </div>
        <div class="modal-body" id="modalBody">
            </div>
    </div>
</div>

<script src="common.js"></script>

<script>
    // API è¨­å®š
    const API_URL = "https://script.google.com/macros/s/AKfycbwqP_rRkI8xyVYFvo8nWY9pq4i1OLlvrLfAMxmleSAh-XDbMQN3yGk3eF0j5OdDDVMYxw/exec";

    let rawData = { headers: [], cnHeaders: [], units: [], dgLimits: { upper: [], lower: [] }, egLimits: { upper: [], lower: [] }, data: [] };
    let chartInstance = null;
    const LINE_COLORS = ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080'];

    function startApp() {
        if(localStorage.getItem('oil_theme') === 'dark') document.body.setAttribute('data-theme', 'dark');
        fetchData();
    }

    async function fetchData() {
        try {
            const res = await fetch(API_URL + "?mode=oil");
            const json = await res.json();
            
            if(json.dgLimits && json.egLimits) {
                rawData = json;
            } else {
                rawData.headers = json.headers || [];
                rawData.cnHeaders = json.cnHeaders || [];
                rawData.units = json.units || [];
                rawData.data = json.data || [];
                rawData.dgLimits = { upper: json.upperLimits || [], lower: json.lowerLimits || [] };
                rawData.egLimits = { upper: json.upperLimits || [], lower: json.lowerLimits || [] };
            }

            document.getElementById('loading').style.display = 'none';
            initControls();      
            renderOverviewTables(); 
        } catch (e) {
            console.error("Error:", e);
            document.getElementById('loading').innerText = "è¼‰å…¥å¤±æ•—";
        }
    }

    function toggleTheme() {
        const body = document.body;
        const next = body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
        body.setAttribute('data-theme', next);
        localStorage.setItem('oil_theme', next);
        if(chartInstance) updateChart();
    }

    // ç‹€æ…‹æª¢æŸ¥
    function checkStatus(val, colIdx, isEG) {
        if (val === "" || val === undefined) return true; 
        let num = parseFloat(val);
        if (isNaN(num)) return true; 
        
        const limits = isEG ? rawData.egLimits : rawData.dgLimits;
        if (!limits || !limits.lower || !limits.upper) return true;

        const lower = limits.lower[colIdx];
        const upper = limits.upper[colIdx];

        if (lower !== "" && num < parseFloat(lower)) return false;
        if (upper !== "" && num > parseFloat(upper)) return false;
        return true;
    }

    function getLimitText(colIdx, isEG) {
        const limits = isEG ? rawData.egLimits : rawData.dgLimits;
        if (!limits || !limits.lower || !limits.upper) return "-";
        const lower = limits.lower[colIdx];
        const upper = limits.upper[colIdx];
        if(lower !== "" && upper !== "") return `${lower}~${upper}`;
        if(lower !== "") return `>${lower}`;
        if(upper !== "") return `<${upper}`;
        return "-";
    }

    function getAllMachines() {
        let machines = [];
        if (rawData.data) machines = rawData.data.map(r => r[1]);
        // é€™è£¡æ²’æœ‰ filterï¼Œæ‰€ä»¥æ‰€æœ‰æ©Ÿçµ„ (#1~#12, EG) éƒ½æœƒé¡¯ç¤º
        return [...new Set(machines)].sort((a,b) => a.localeCompare(b, undefined, {numeric: true}));
    }

    function initControls() {
        const machines = getAllMachines();
        const years = new Set();
        rawData.data.forEach(r => { 
            if(r[0]) { const y = r[0].substring(0, 4); if(y) years.add(y); }
        });
        const sortedYears = [...years].sort().reverse();

        const tYearSelect = document.getElementById('tableYear');
        const cYearSelect = document.getElementById('chartYear');
        sortedYears.forEach(y => {
            tYearSelect.innerHTML += `<option value="${y}">${y}å¹´</option>`;
            cYearSelect.innerHTML += `<option value="${y}">${y}å¹´</option>`;
        });

        const mBox = document.getElementById('machineCheckboxes');
        mBox.innerHTML = "";
        machines.forEach((m, idx) => {
            const checked = (idx === 0) ? 'checked' : '';
            mBox.innerHTML += `<label class="checkbox-item"><input type="checkbox" value="${m}" ${checked} onchange="updateChart()"> ${m}</label>`;
        });
        
        const pSelect = document.getElementById('chartParam');
        for(let i=2; i<rawData.headers.length - 1; i++) { 
            const name = rawData.cnHeaders[i] || rawData.headers[i];
            pSelect.innerHTML += `<option value="${rawData.headers[i]}">${name}</option>`;
        }
        updateChart();
    }

    // æ¸²æŸ“ç¸½è¦½è¡¨æ ¼ (å·²ç§»é™¤ã€Œåˆ¤å®šã€æ¬„ä½)
    function renderOverviewTables() {
        document.getElementById('dgTable').innerHTML = "";
        document.getElementById('egTable').innerHTML = "";
        const selectedYear = document.getElementById('tableYear').value;
        const selectedMonth = document.getElementById('tableMonth').value;

        const machineGroups = {}; 
        rawData.data.forEach(row => {
            const mId = row[1]; 
            if (!machineGroups[mId]) machineGroups[mId] = [];
            machineGroups[mId].push(row);
        });

        const allKeys = Object.keys(machineGroups);
        const dgKeys = allKeys.filter(k => !k.toUpperCase().includes('EG')).sort((a,b) => a.localeCompare(b, undefined, {numeric: true}));
        const egKeys = allKeys.filter(k => k.toUpperCase().includes('EG')).sort((a,b) => a.localeCompare(b, undefined, {numeric: true}));

        generateTable('dgTable', dgKeys, machineGroups, selectedYear, selectedMonth, false);
        generateTable('egTable', egKeys, machineGroups, selectedYear, selectedMonth, true);
    }

    function generateTable(tableId, keys, machineGroups, selectedYear, selectedMonth, isEG) {
        const table = document.getElementById(tableId);
        if(keys.length === 0) { table.innerHTML = "<tbody><tr><td>ç„¡è³‡æ–™</td></tr></tbody>"; return; }

        let thead = document.createElement('thead');
        let trHead = document.createElement('tr');
        trHead.innerHTML = `<th>æ©Ÿçµ„</th><th>æª¢é©—æ—¥æœŸ</th>`;
        for (let i = 2; i < rawData.headers.length - 1; i++) { 
            const cnName = rawData.cnHeaders[i] || rawData.headers[i];
            const unit = rawData.units[i] ? `<span class="unit-small">(${rawData.units[i]})</span>` : '';
            const th = document.createElement('th');
            th.innerHTML = `${cnName} ${unit}`;
            trHead.appendChild(th);
        }
        // â–¼ ç§»é™¤åˆ¤å®šæ¬„ä½è¡¨é ­
        // const thDiag = document.createElement('th'); thDiag.innerText = "åˆ¤å®š"; trHead.appendChild(thDiag);
        
        thead.appendChild(trHead);
        table.appendChild(thead);

        let tbody = document.createElement('tbody');
        keys.forEach(key => {
            const history = machineGroups[key].sort((a, b) => new Date(b[0]) - new Date(a[0]));
            let targetRow = null;
            if (selectedYear === 'latest') {
                targetRow = history[0];
            } else {
                targetRow = history.find(row => {
                    const d = new Date(row[0]);
                    const y = d.getFullYear().toString();
                    const m = (d.getMonth() + 1).toString();
                    if (selectedMonth === 'all') return y === selectedYear;
                    return y === selectedYear && m === selectedMonth;
                });
            }

            if (!targetRow) {
                let tr = document.createElement('tr');
                tr.innerHTML = `<td>${key}</td><td style="color:#ccc">ç„¡æ•¸æ“š</td>`;
                for(let k=2; k<rawData.headers.length - 1; k++) tr.innerHTML += `<td>-</td>`;
                tbody.appendChild(tr);
                return;
            }

            const dateStr = targetRow[0].split('T')[0];
            const diagIdx = rawData.headers.length - 1;
            const diagText = targetRow[diagIdx]; // å»ºè­°äº‹é …å…§å®¹
            
            let tr = document.createElement('tr');
            tr.onclick = () => openModal(key, history.slice(0, 3), isEG);

            // è¨ˆç®—ç‹€æ…‹ (ç”¨æ–¼é¡¯ç¤ºæ©Ÿçµ„æ—çš„ç´…ç¶ ç‡ˆ)
            let hasError = false;
            for (let i = 2; i < rawData.headers.length - 1; i++) {
                if (!checkStatus(targetRow[i], i, isEG)) { hasError = true; break; }
            }
            const dotClass = hasError ? "dot-err" : "dot-ok";

            let tdName = document.createElement('td');
            // ä¿ç•™ç´…ç¶ ç‡ˆï¼Œä½†ç§»é™¤åˆ¤å®šæ¬„ä½
            tdName.innerHTML = `<span class="status-dot ${dotClass}"></span>${key}`;
            // å¦‚æœæœ‰å»ºè­°äº‹é …ï¼Œé¡¯ç¤ºå°åœ–ç¤º
            if (diagText && diagText.trim() !== "") {
                tdName.innerHTML += `<span class="diagnosis-text" title="æœ‰å»ºè­°äº‹é …"> ğŸ“</span>`;
            }
            tr.appendChild(tdName);

            let tdDate = document.createElement('td');
            tdDate.innerText = dateStr;
            tr.appendChild(tdDate);

            for (let i = 2; i < rawData.headers.length - 1; i++) {
                let td = document.createElement('td');
                let val = targetRow[i];
                if (!checkStatus(val, i, isEG)) {
                    td.className = "val-limit";
                    td.title = `æ¨™æº–: ${getLimitText(i, isEG)}`;
                }
                td.innerText = val;
                tr.appendChild(td);
            }
            // â–¼ ç§»é™¤åˆ¤å®šçµæœçš„ td
            // let tdDiag = document.createElement('td'); ... tr.appendChild(tdDiag);

            tbody.appendChild(tr);
        });
        table.appendChild(tbody);
    }

    // --- Modal (è©³ç´°è¦–çª—ï¼šå»ºè­°é¡¯ç¤ºåœ¨æœ€ä¸Šæ–¹) ---
    function openModal(machineId, historyRows, isEG) {
        const modal = document.getElementById('detailModal');
        const modalBody = document.getElementById('modalBody'); // å–å¾— body å®¹å™¨
        document.getElementById('modalTitle').innerText = `${machineId} - è©³ç´°æ­·å²ç´€éŒ„`;
        
        // 1. è™•ç†å»ºè­°äº‹é … (æ”¾åœ¨æœ€ä¸Šæ–¹)
        const diagIdx = rawData.headers.length - 1;
        const latestDiag = historyRows[0][diagIdx];
        let adviceHtml = "";
        
        // æª¢æŸ¥æ˜¯å¦æœ‰ç•°å¸¸ (æ±ºå®šå»ºè­°æ¡†é¡è‰²)
        let hasError = false;
        for (let i = 2; i < rawData.headers.length - 1; i++) {
            if (!checkStatus(historyRows[0][i], i, isEG)) { hasError = true; break; }
        }
        const alertClass = hasError ? "alert-danger" : "alert-info"; // ç´…è‰²æˆ–è—è‰²æ¡†
        const diagText = (latestDiag && latestDiag.trim() !== "") ? latestDiag : "æœ¬æ¬¡åŒ–é©—ç„¡ç‰¹åˆ¥å»ºè­°äº‹é …ã€‚";

        adviceHtml = `
            <div class="advice-box ${alertClass}" style="padding:15px; margin-bottom:15px; border-radius:8px; border-left:5px solid; background-color:${hasError?'#ffebee':'#e3f2fd'}; border-left-color:${hasError?'#f44336':'#2196f3'}; color:${hasError?'#b71c1c':'#0d47a1'};">
                <strong>ğŸ“ æœ€æ–°å»ºè­° (${historyRows[0][0].split('T')[0]})ï¼š</strong><br>
                ${diagText}
            </div>
        `;

        // 2. å»ºç«‹è©³ç´°è¡¨æ ¼
        let tableHtml = `<table class="detail-table" style="width:100%; border-collapse:collapse;"><thead><tr><th style="text-align:left; background:var(--table-head-bg);">æª¢é©—é …ç›®</th><th style="background:var(--table-head-bg);">æ¨™æº–</th>`;
        
        historyRows.forEach((row, idx) => {
            const date = row[0].split('T')[0];
            tableHtml += `<th class="${idx===0?'col-latest':''}" style="background:var(--table-head-bg);">${date}</th>`;
        });
        for(let i=historyRows.length; i<3; i++) tableHtml += `<th style="background:var(--table-head-bg);">-</th>`;
        tableHtml += `</tr></thead><tbody>`;

        for(let i=2; i<rawData.headers.length - 1; i++) {
            const cnName = rawData.cnHeaders[i] || rawData.headers[i];
            const unit = rawData.units[i] || "";
            let limitText = getLimitText(i, isEG);
            
            tableHtml += `<tr><td style="text-align:left; font-weight:bold;">${cnName} <span style="color:#888;font-size:0.8em">(${unit})</span></td><td style="color:#666;font-size:0.85em">${limitText}</td>`;
            for(let j=0; j<3; j++) {
                const isLatest = (j === 0) ? 'col-latest' : '';
                if (j < historyRows.length) {
                    const val = historyRows[j][i];
                    const valClass = checkStatus(val, i, isEG) ? "" : "val-limit";
                    // è©³ç´°è¡¨æ ¼åŠ ä¸Šåº•ç·šæ¨£å¼
                    tableHtml += `<td class="${isLatest} ${valClass}" style="border-bottom:1px solid var(--border-color); padding:8px;">${val}</td>`;
                } else { tableHtml += `<td class="${isLatest}" style="border-bottom:1px solid var(--border-color);"> - </td>`; }
            }
            tableHtml += `</tr>`;
        }
        tableHtml += `</tbody></table>`;

        // çµ„åˆå…§å®¹
        modalBody.innerHTML = adviceHtml + tableHtml;
        modal.style.display = 'block';
    }
    function closeModal() { document.getElementById('detailModal').style.display = 'none'; }
    window.onclick = function(event) { if (event.target == document.getElementById('detailModal')) closeModal(); }

    // --- åœ–è¡¨æ›´æ–° ---
    function updateChart() {
        const checkboxes = document.querySelectorAll('#machineCheckboxes input:checked');
        const selectedMachines = Array.from(checkboxes).map(cb => cb.value);
        const year = document.getElementById('chartYear').value;
        const pKey = document.getElementById('chartParam').value;

        if (selectedMachines.length === 0) {
            if(chartInstance) chartInstance.data.datasets = []; chartInstance.update(); return;
        }

        let datasets = [];
        let allLabels = new Set();
        const pIdx = rawData.headers.indexOf(pKey);

        const isAllEG = selectedMachines.every(m => m.includes('EG'));
        const limits = isAllEG ? rawData.egLimits : rawData.dgLimits;
        const lower = limits ? parseFloat(limits.lower[pIdx]) : NaN;
        const upper = limits ? parseFloat(limits.upper[pIdx]) : NaN;

        selectedMachines.forEach((mId, index) => {
            const filteredData = rawData.data.filter(r => {
                const isMachineMatch = (r[1] === mId);
                const isYearMatch = (year === 'all') || (r[0].startsWith(year));
                return isMachineMatch && isYearMatch;
            }).sort((a, b) => new Date(a[0]) - new Date(b[0]));

            filteredData.forEach(r => allLabels.add(r[0].split('T')[0]));

            const dataPoints = filteredData.map(r => {
                const d = r[0].split('T')[0];
                return { x: d, y: parseFloat(r[pIdx]) || null };
            });

            datasets.push({
                label: mId,
                data: dataPoints,
                borderColor: LINE_COLORS[index % LINE_COLORS.length],
                backgroundColor: LINE_COLORS[index % LINE_COLORS.length],
                borderWidth: 1.5, pointRadius: 0, fill: false, tension: 0.1, spanGaps: true
            });
        });

        const sortedLabels = Array.from(allLabels).sort();
        
        datasets.forEach(ds => {
             const newData = sortedLabels.map(lbl => {
                 const pt = ds.data.find(p => p.x === lbl);
                 return pt ? pt.y : null;
             });
             ds.data = newData;
        });

        if (!isNaN(upper)) datasets.push({ label: 'ä¸Šé™', data: new Array(sortedLabels.length).fill(upper), borderColor: '#dc3545', borderWidth: 1, borderDash: [5, 5], pointRadius: 0, fill: false });
        if (!isNaN(lower)) datasets.push({ label: 'ä¸‹é™', data: new Array(sortedLabels.length).fill(lower), borderColor: '#dc3545', borderWidth: 1, borderDash: [5, 5], pointRadius: 0, fill: false });

        const ctx = document.getElementById('historyChart').getContext('2d');
        if (chartInstance) chartInstance.destroy();
        const isDark = document.body.getAttribute('data-theme') === 'dark';
        const gridColor = isDark ? '#444' : '#ddd';
        const textColor = isDark ? '#eee' : '#666';

        chartInstance = new Chart(ctx, {
            type: 'line',
            data: { labels: sortedLabels, datasets: datasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: { 
                    y: { beginAtZero: false, grid: {color: gridColor}, ticks: {color: textColor} },
                    x: { grid: {color: gridColor}, ticks: { color: textColor, maxTicksLimit: 12, maxRotation: 0 } }
                },
                plugins: { legend: { labels: { color: textColor } } }
            }
        });
    }
</script>

</body>
</html>
